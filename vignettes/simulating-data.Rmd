---
title: "Simulating Multivariate Data with `tidymvsim`"
author: "Eric R. Scott"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulating Multivariate Data with tidymvsim}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# To-do:

- look at vignettes for some other tidyverse package to get ideas for organization/section titles

# Introduction

To simulate co-varying multivariate normal data one can use the `mvrnorm()` function from the `MASS` package. However, this requires input of a covariance matrix and returns a matrix.  The `tidymvsim` package provides functions that are "tidy" in the sense that they work with dataframes and the pipe operator (`%>%`).  Here, I'll demonstrate how to create some multivariate datasets, explore them with the `corrr` package, and analyze data with principal component analysis (PCA) and partial least squares discriminant analysis (PLS-DA) using the `ropls` package


# Simulate data

To simulate multivariate data you need to start with a data frame or a tibble.  Once you have a dataframe or tibble, the `sim_*()` functions add columns onto it.

```{r}
library(tidymvsim)
library(dplyr)

df <- tibble(Y = rep(c("a", "b"), each = 5))
df %>% sim_covar(p = 5, var = 1, cov = 0.5)
```


Optionally you can create a tibble with the `sim_covar()` or `sim_cat()` functions by providing them with the `N`  argument instead of `.data`.

```{r}
sim_covar(N = 10, p = 5, var = 1, cov = 0.5)
```

`sim_cat()` is a rather simple wrapper that just creates a column of categorical data. Eventually, it will be expanded to allow creation of crossed and nested factors.

```{r}
sim_cat(N = 10, n_groups = 2)
```

`sim_discr()` simulates covarying data that differs in means between levels of some grouping variable.

```{r}
df %>%
  group_by(Y) %>% 
  sim_discr(p = 5, var = 1, cov = 0.1, group_means = c(1, -1))
```


# Chaining functions with `%>%`

One advantage of the `tidymvsim` package is the ability to chain functions together to create complex data covariance structures. You can chain functions together in any order although the `sim_discr()` function requires a grouping variable.

First, let's create a tibble with two groups of co-varying variables and visualize the covariance structure. All of the `sim_*` functions (besides `sim_missing()`) take an optional name argument which names the variables created.

```{r}
df <-
  sim_covar(N = 20, p = 3, var = 1, cov = 0.1, name = "low") %>% #5 variables with low covariance
  sim_covar(p = 4, var = 1, cov = 0.8, name = "high")            #5 variables with high covariance
df
```

Now we could add a categorial variable, and some variables that discriminate between levels of our categorical variable

```{r}
df1 <-
  df %>% 
  sim_cat(n_groups = 2, name = "factor") %>% 
  group_by(factor) %>% 
  sim_discr(p = 5, var = 1, cov = 0.1, group_means = c(-1, 1), name = "discr")
df1
```

Finally, if you want to simulate missing values, you can use `sim_missing()` to randomly introduce NAs.

```{r}
df2 <-
  df1 %>% 
  sim_missing(prop = 0.1)
df2 <- ungroup(df2)
df2
```

# Visualizing correlation

The [corrr](https://github.com/drsimonj/corrr) package provides tools for viusalizing correlation structures.

```{r}
library(corrr)
x <-
  df2 %>%
  select(-factor) %>% 
  correlate() %>% #creates a correlation dataframe
  shave() #removes uppper triangle
```

```{r fig.width=6}
rplot(x) 
```

# Analyzing data

One reason you might want to simulate multivariate data used to test and compare a variety of statistical techniques. This package also contains some wrappers that help deal with model objects created by the `opls()` function from the `ropls` package. Refer to documentation on `opls()` for how to use it for PCA and PLS-DA models

## Do PCA and PLS-DA

```{r}
library(ropls)
pca <- opls(select(df2, -factor), plotL = FALSE, printL = FALSE)
plsda <- opls(select(df2, -factor), df2$factor, plotL = FALSE, printL = FALSE, predI = 2)
```

After creating these models, we can create default plots using `plot_pca()` and `plot_plsda()` which use `ggplot2`.

```{r fig.width=6}
chemhelper::plot_pca(pca, group_var = df2$factor)
```

```{r fig.width=6}
chemhelper::plot_plsda(plsda)
```

And we can use some accessor functions to get scores, loadings, and VIP scores (for PLS)

**PCA**

```{r}
#pca scores and loadings
chemhelper::get_scores(pca)
chemhelper::get_loadings(pca) %>%
  arrange(desc(abs(p1)))
```

**PLS_DA**

```{r}
chemhelper::get_scores(plsda)
chemhelper::get_loadings(plsda) %>%
  arrange(desc(abs(p1)))
chemhelper::get_VIP(plsda) %>% 
  arrange(desc(VIP))
```

